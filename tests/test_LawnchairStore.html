<!DOCTYPE html>
<html>
	<body>
		<p>Open the console to see test results.</p>
		<script type="text/javascript">
			djConfig = {
				isDebug: true, //provide console for e.g. old IEs
				require: [
					'doh.runner', //NOTE: this lives in util (src release only)!
					'kgf.lawnchair.LawnchairStore',
					// test on-demand loading by not requiring adaptors manually
					'kgf.lawnchair.tests.testHelpers'
				]
			}
		</script>
		<script type="text/javascript" src="../../../dojo/dojo.js"></script>
		<script type="text/javascript">
			var store;
			
			dojo.ready(function() {
				
				function setUp() {
					store.nuke();
				}
				
				var
					LawnchairStore = kgf.lawnchair.LawnchairStore,
					lcOpts = kgf.lawnchair.tests.testHelpers.getOptsFromQuery();
				kgf.lawnchair.tests.testHelpers.addInfo('LawnchairStore');
				
				//NOTE: the tests here unconditionally use .then since the store methods
				//in LawnchairStore are known to return promises.
				//However, dojo.when should be used in general cases where the type
				//of store is not known, since dojo.store API methods are permitted
				//to return promises or immediate results.
				
				doh.registerGroup('LawnchairStore', [
					{
						name: 'ctor',
						runTest: function(doh) {
							var
								dfd = new doh.Deferred(),
								derr = dojo.hitch(dfd, 'errback');
							
							//note: this instance is used by future tests as well.
							//it is purposely global to be accessible later from console.
							store = new LawnchairStore(lcOpts);
							//run a quick test function just to prove that they wait properly
							store.query().then(function(items) {
								doh.t(dojo.isArray(items),
									'store calls should properly defer until adaptor is loaded');
								dfd.callback(true);
							}, derr);
							return dfd;
						}
					},
					{
						name: 'nuke()',
						setUp: setUp,
						runTest: function(doh) {
							var
								dfd = new doh.Deferred(),
								derr = dojo.hitch(dfd, 'errback');
							
							store.query().then(function(items) {
								doh.is(items.length, 0, 'should have 0 items after nuke');
								return store.add({ some: 'thing' });
							}, derr).then(function() {
								return store.nuke();
							}, derr).then(function() {
								return store.query();
							}, derr).then(function(items) {
									doh.is(items.length, 0,
										'should have 0 items again after save + nuke');
									dfd.callback(true);
							}, derr);
							return dfd;
						}
					},
					{
						name: 'add() / put() / getIdentity()',
						setUp: setUp,
						runTest: function(doh) {
							var
								dfd = new doh.Deferred(),
								derr = dojo.hitch(dfd, 'errback'),
								testObj = { some: 'thing' },
								testKey = 'neversaydie';
							store.add(testObj).then(function(item) {
								doh.is(testObj, item,
									'should pass original (now saved) object through chain');
								return store.add({ something: 'else' });
							}, derr).then(function(item) {
								var key = store.getIdentity(item);
								//test >= 36 since some adaptors add to UUID (e.g. UserData)
								doh.t(key && key.length >= 36,
									'item without key should have one autogenerated upon add');
								return store.query();
							}, derr).then(function(items) {
								doh.is(items.length, 2,
									'should have length 2 after 2 unique-key saves');
								return store.add({ foo: 'bar' }, { id: testKey });
							}, derr).then(function(item) {
								doh.is(store.getIdentity(item), testKey,
									'should set given key');
								return store.query();
							}, derr).then(function(items) {
								doh.is(items.length, 3,
									'should have length 3 after 3 unique-key saves');
								return store.put({ key: testKey, foo: 'baz' });
							}, derr).then(function() {
								//test put using options.id
								return store.put({ foo: 'bim' }, { id: testKey });
							}, derr).then(function() {
								return store.query();
							}, derr).then(function(items) {
								doh.is(items.length, 3,
									'should still have length 3 after existing-key puts');
								return store.add({ key: testKey, foo: 'baz' });
							}, derr).then(
								function() {
									//deferred errors don't seem to propagate informatively...
									derr(new doh._AssertFailure('adding with existing id should throw'));
								}, function(e) {
									doh.isNot(e.message.indexOf('already-existing'), -1,
										'Ensure expected error (not from a previous test failure)');
									//seems like the (caught!) error gets logged here...
									console.log('ignore "already-existing key" errors, the test passed');
									dfd.callback(true);
								}
							);
							return dfd;
						}
					},
					{
						name: 'get()',
						setUp: setUp,
						runTest: function(doh) {
							var
								dfd = new doh.Deferred(),
								derr = dojo.hitch(dfd, 'errback');

							store.add({ key: 'xyz123', name: 'tim' }).then(function() {
								return store.get('xyz123');
							}, derr).then(function(item) {
								doh.is(item.name, 'tim',
									'calling get with an existing key should return expected object');
								return store.get('inai');
							}, derr).then(function(item) {
								doh.t(item === null,
									'nonexistent key should pass null to callback');
								dfd.callback(true);
							}, derr);
							return dfd;
						}
					},
					{
						name: 'query()',
						setUp: setUp,
						runTest: function(doh) {
							//breaking this up a bit since it's ridiculously nesty.
							//(this is why they DID write that chain function...)
							function testFilter(item) {
								return item.name == 'crash test dummy';
							}
							
							var
								dfd = new doh.Deferred(),
								derr = dojo.hitch(dfd, 'errback'),
								testObj = { name: 'crash test dummy', crashes: 9000 };
							
							//tests start here, call the func above partway in
							store.add(testObj).then(function() {
								return store.add({ name: 'something' });
							}, derr).then(function() {
								//test unfiltered query
								return store.query();
							}, derr).then(function(results) {
								doh.is(results.length, 2,
									'unfiltered query should have 2 results');
								//test object query
								return store.query({ name: "crash test dummy" });
							}, derr).then(function(results) {
								//NOTE: these tests assume results is an array.
								//This is true of LawnchairStore query results, but not
								//necessarily true of all dojo.stores in general!
								doh.is(results.length, 1, 'query should have 1 result');
								doh.is(results[0].name, testObj.name,
									'should return expected record against object query');
								//test RegExp query
								return store.query({ name: /dummy$/ });
							}, derr).then(function(results) {
								doh.is(results.length, 1, 'query should have 1 result');
								doh.is(results[0].name, testObj.name,
									'should return expected record against RegExp query');
								//test function query
								return store.query(testFilter);
							}, derr).then(function(results) {
								var item = results[0];
								doh.is(results.length, 1, 'query should have 1 result');
								doh.is(item.name, testObj.name,
									'should return expected record against function filter');
								item.crashes = 9001; //WHAT NINE THOUSAND?!
								return store.put(item);
							}, derr).then(function(item) {
								return store.query(testFilter);
							}, derr).then(function(results) {
								var item = results[0];
								doh.is(results.length, 1, 'query should have 1 result');
								doh.is(item.crashes, 9001,
									'should return updated record data after query+put+query');
								dfd.callback(true);
							}, derr);
							return dfd;
						}
					},
					{
						name: 'remove()',
						setUp: setUp,
						runTest: function(doh) {
							var
								dfd = new doh.Deferred(),
								derr = dojo.hitch(dfd, 'errback'),
								testKey = 'mykey';
							
							//yes, 'two' before 'one' - as compared to test_Lawnchair.
							//technically, test 'one' here is superfluous - the object store
							//API doesn't expect it to be supported, but it works because
							//it's passed straight through to Lawnchair which supports it.
							store.add({ key: testKey, name: 'two' }).then(function() {
								return store.query({ name: 'two' });
							}, derr).then(function(results) {
								doh.is(results.length, 1, 'query should find added item');
								return store.remove(testKey);
							}, derr).then(function() {
								return store.query();
							}, derr).then(function(results) {
								doh.is(results.length, 0,
									'should have 0 items after add+find+remove(id)');
								return store.add({ name: 'one' });
							}, derr).then(function() {
								return store.query({ name: 'one' });
							}, derr).then(function(results) {
								doh.is(results.length, 1, 'query should find added item');
								return store.remove(results[0]);
							}, derr).then(function() {
								return store.query();
							}, derr).then(function(results) {
								doh.is(results.length, 0,
									'should have 0 items after add+find+remove(object)');
								dfd.callback(true);
							}, derr);
							return dfd;
						}
					}
				]);
				doh.run();
			});
		</script>
	</body>
</html>
